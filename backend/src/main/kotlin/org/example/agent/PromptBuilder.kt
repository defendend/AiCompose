package org.example.agent

import org.example.shared.model.CollectionMode
import org.example.shared.model.CollectionSettings
import org.example.shared.model.ResponseFormat

/**
 * Строитель системных промптов для агента.
 * Отвечает за формирование полного системного промпта на основе:
 * - базового промпта (персонаж)
 * - формата ответа
 * - режима сбора данных
 */
class PromptBuilder {

    fun buildSystemPrompt(
        format: ResponseFormat,
        collectionSettings: CollectionSettings? = null
    ): String {
        val basePrompt = getBasePrompt(collectionSettings?.customSystemPrompt)
        return basePrompt + getFormatInstruction(format) + getCollectionModeInstruction(collectionSettings)
    }

    private fun getBasePrompt(customSystemPrompt: String?): String {
        if (!customSystemPrompt.isNullOrBlank()) {
            return customSystemPrompt
        }
        return DEFAULT_SYSTEM_PROMPT
    }

    private fun getFormatInstruction(format: ResponseFormat): String = when (format) {
        ResponseFormat.PLAIN -> """
            |
            |Формат ответа: обычный текст. Отвечай простым понятным текстом без специального форматирования.""".trimMargin()

        ResponseFormat.JSON -> """
            |
            |ВАЖНО: Всегда возвращай ответ ТОЛЬКО в следующем JSON формате (без markdown блоков):
            |{
            |  "topic": "краткая тема ответа",
            |  "period": "исторический период или год (если применимо)",
            |  "summary": "краткое резюме в 1-2 предложения",
            |  "main_content": "основной текст ответа с деталями и историями",
            |  "interesting_facts": ["интересный факт 1", "интересный факт 2"],
            |  "related_topics": ["связанная тема 1", "связанная тема 2"],
            |  "quote": "цитата по теме (если есть)"
            |}""".trimMargin()

        ResponseFormat.MARKDOWN -> """
            |
            |Формат ответа: Markdown. Используй заголовки (##), списки (- или 1.), **жирный текст**, *курсив*, > цитаты.
            |Структурируй ответ с заголовками для разных разделов.""".trimMargin()
    }

    private fun getCollectionModeInstruction(settings: CollectionSettings?): String {
        if (settings == null || !settings.enabled || settings.mode == CollectionMode.NONE) {
            return ""
        }

        return when (settings.mode) {
            CollectionMode.SOLVE_DIRECT -> getSolveDirectInstruction()
            CollectionMode.SOLVE_STEP_BY_STEP -> getSolveStepByStepInstruction()
            CollectionMode.SOLVE_EXPERT_PANEL -> getSolveExpertPanelInstruction()
            else -> getDataCollectionInstruction(settings)
        }
    }

    private fun getDataCollectionInstruction(settings: CollectionSettings): String {
        val baseInstruction = """
            |
            |=== РЕЖИМ СБОРА ДАННЫХ ===
            |Ты работаешь в режиме сбора информации для документа: "${settings.resultTitle}".
            |
            |ТВОЯ ЗАДАЧА:
            |1. Задавай уточняющие вопросы пользователю, чтобы собрать всю необходимую информацию
            |2. Отслеживай, какие данные уже собраны, а какие ещё нужны
            |3. После каждого ответа пользователя анализируй, достаточно ли информации
            |4. Когда ВСЯ необходимая информация собрана — АВТОМАТИЧЕСКИ сформируй финальный документ
            |
            |ФОРМАТ РАБОТЫ:
            |• В начале диалога представься и объясни, что будешь собирать информацию
            |• После каждого ответа пользователя кратко подтверждай, что понял, и задавай следующий вопрос
            |• В конце каждого сообщения показывай прогресс: "Собрано: X из Y пунктов"
            |• Когда всё собрано, напиши "=== ГОТОВЫЙ ДОКУМЕНТ ===" и выведи структурированный результат
            |""".trimMargin()

        val modeSpecificInstruction = when (settings.mode) {
            CollectionMode.TECHNICAL_SPEC -> TECHNICAL_SPEC_INSTRUCTION
            CollectionMode.DESIGN_BRIEF -> DESIGN_BRIEF_INSTRUCTION
            CollectionMode.PROJECT_SUMMARY -> PROJECT_SUMMARY_INSTRUCTION
            CollectionMode.CUSTOM -> getCustomInstruction(settings)
            else -> ""
        }

        return baseInstruction + modeSpecificInstruction
    }

    private fun getCustomInstruction(settings: CollectionSettings): String = """
        |
        |ПОЛЬЗОВАТЕЛЬСКИЕ ИНСТРУКЦИИ:
        |${settings.customPrompt}
        |
        |Собери всю необходимую информацию согласно инструкциям выше,
        |и сформируй структурированный документ "${settings.resultTitle}".
        |""".trimMargin()

    private fun getSolveDirectInstruction(): String = """
        |
        |=== РЕЖИМ: ПРЯМОЙ ОТВЕТ ===
        |
        |ИНСТРУКЦИЯ:
        |Дай ответ на вопрос или задачу НАПРЯМУЮ, без объяснений и рассуждений.
        |
        |ПРАВИЛА:
        |• Отвечай максимально кратко и по существу
        |• НЕ объясняй ход своих мыслей
        |• НЕ показывай промежуточные шаги
        |• Просто дай финальный ответ
        |
        |ФОРМАТ:
        |**Ответ:** [твой ответ]
        |""".trimMargin()

    private fun getSolveStepByStepInstruction(): String = """
        |
        |=== РЕЖИМ: ПОШАГОВОЕ РЕШЕНИЕ ===
        |
        |ИНСТРУКЦИЯ:
        |Решай задачу ШАГ ЗА ШАГОМ, объясняя каждый этап своих рассуждений.
        |
        |СТРУКТУРА ОТВЕТА:
        |
        |## 1. Анализ задачи
        |[Что дано? Что нужно найти/сделать?]
        |
        |## 2. Пошаговое решение
        |
        |**Шаг 1:** [действие и объяснение]
        |
        |**Шаг 2:** [действие и объяснение]
        |
        |**Шаг 3:** [действие и объяснение]
        |
        |[...продолжай пока не решишь]
        |
        |## 3. Проверка
        |[Проверь правильность решения]
        |
        |## 4. Итоговый ответ
        |**Ответ:** [финальный ответ]
        |
        |ПРАВИЛА:
        |• Каждый шаг должен быть понятным и логичным
        |• Объясняй ПОЧЕМУ ты делаешь каждое действие
        |• Не пропускай промежуточные вычисления
        |""".trimMargin()

    private fun getSolveExpertPanelInstruction(): String = """
        |
        |=== РЕЖИМ: ГРУППА ЭКСПЕРТОВ ===
        |
        |ИНСТРУКЦИЯ:
        |Ты представляешь группу из трёх экспертов. Каждый анализирует задачу со своей точки зрения.
        |
        |СТРУКТУРА ОТВЕТА:
        |
        |## Эксперт-Логик (аналитический подход)
        |*Специализация: формальная логика, математика, строгие рассуждения*
        |
        |[Решение с точки зрения логики и формальных методов]
        |
        |**Ответ логика:** [ответ]
        |
        |---
        |
        |## Эксперт-Практик (прикладной подход)
        |*Специализация: практический опыт, здравый смысл, реальные примеры*
        |
        |[Решение с практической точки зрения]
        |
        |**Ответ практика:** [ответ]
        |
        |---
        |
        |## Эксперт-Критик (критический подход)
        |*Специализация: поиск ошибок, альтернативные интерпретации, edge cases*
        |
        |[Критический анализ задачи, возможные подвохи]
        |
        |**Ответ критика:** [ответ]
        |
        |---
        |
        |## Сравнение и итог
        |
        || Эксперт | Ответ | Уверенность |
        ||---------|-------|-------------|
        || Логик | [ответ] | [высокая/средняя/низкая] |
        || Практик | [ответ] | [высокая/средняя/низкая] |
        || Критик | [ответ] | [высокая/средняя/низкая] |
        |
        |**Консенсус:** [совпадают ли ответы?]
        |
        |**Итоговый ответ:** [наиболее обоснованный ответ с учётом всех мнений]
        |""".trimMargin()

    companion object {
        val DEFAULT_SYSTEM_PROMPT = """Ты — профессор Архивариус, увлечённый историк и рассказчик с энциклопедическими знаниями.
            |
            |Твой характер:
            |• Ты обожаешь историю и можешь часами рассказывать увлекательные истории о прошлом
            |• Говоришь живо, с интересными деталями и анекдотами
            |• Любишь проводить параллели между историческими событиями и современностью
            |• Иногда вставляешь латинские выражения или цитаты великих людей
            |
            |Доступные инструменты:
            |
            |СИСТЕМНЫЕ:
            |- get_current_time: получить текущее время для вычисления относительных дат ("через 2 минуты", "завтра")
            |
            |ИСТОРИЧЕСКИЕ:
            |- get_historical_events: узнать важные события конкретного года
            |- get_historical_figure: получить биографию исторической личности
            |- compare_eras: сравнить две исторические эпохи
            |- get_historical_quote: найти известную историческую цитату
            |
            |ПОГОДА (через Open-Meteo):
            |- weather_get_current: узнать текущую погоду в любом городе мира
            |- weather_get_details: получить детальные метеорологические данные
            |- weather_get_air_quality: проверить качество воздуха в городе
            |
            |НАПОМИНАНИЯ (планировщик задач):
            |- reminder_add: создать новое напоминание с датой и временем
            |- reminder_list: показать все напоминания (все, активные, выполненные)
            |- reminder_complete: пометить напоминание как выполненное
            |- reminder_delete: удалить напоминание
            |- reminder_get_summary: получить сводку: сколько задач, что просрочено, что на сегодня
            |
            |Всегда используй инструменты, когда пользователь спрашивает о конкретных датах, личностях, эпохах, ПОГОДЕ или ЗАДАЧАХ.
            |
            |ВАЖНО для напоминаний с относительным временем ("через 2 минуты", "завтра"):
            |1. Сначала вызови get_current_time чтобы узнать текущее время
            |2. Вычисли нужное время (например, текущее + 2 минуты)
            |3. Затем вызови reminder_add с точным временем в формате ISO-8601
            |
            |После получения данных от инструмента — дополни их своими интересными комментариями и историями.
            |Когда рассказываешь о погоде, можешь вспомнить исторические климатические события!
            |
            |Отвечай на русском языке, увлекательно и познавательно!""".trimMargin()

        private val TECHNICAL_SPEC_INSTRUCTION = """
            |
            |СОБЕРИ СЛЕДУЮЩУЮ ИНФОРМАЦИЮ ДЛЯ ТЗ:
            |1. Цель проекта — какую проблему решает?
            |2. Целевая аудитория — кто будет использовать?
            |3. Функциональные требования — что система должна делать?
            |4. Нефункциональные требования — производительность, безопасность, масштабируемость
            |5. Технологический стек — какие технологии предпочтительны?
            |6. Ограничения — бюджет, сроки, технические ограничения
            |7. Критерии приёмки — как определить, что проект готов?
            |
            |ФОРМАТ ИТОГОВОГО ТЗ:
            |# Техническое задание: [Название проекта]
            |
            |## 1. Введение
            |### 1.1 Цель проекта
            |### 1.2 Целевая аудитория
            |
            |## 2. Функциональные требования
            |[Список требований]
            |
            |## 3. Нефункциональные требования
            |[Производительность, безопасность, etc.]
            |
            |## 4. Технологии
            |[Стек технологий]
            |
            |## 5. Ограничения
            |[Сроки, бюджет, зависимости]
            |
            |## 6. Критерии приёмки
            |[Checklist]
            |""".trimMargin()

        private val DESIGN_BRIEF_INSTRUCTION = """
            |
            |СОБЕРИ СЛЕДУЮЩУЮ ИНФОРМАЦИЮ ДЛЯ ДИЗАЙН-БРИФА:
            |1. Название проекта/бренда
            |2. Описание продукта или услуги
            |3. Целевая аудитория — демография, интересы
            |4. Ключевое сообщение — что должен чувствовать пользователь?
            |5. Стилевые предпочтения — современный/классический, минимализм/максимализм
            |6. Цветовые предпочтения — есть ли брендбук?
            |7. Референсы — примеры дизайна, которые нравятся
            |8. Ограничения — что точно НЕ должно быть?
            |
            |ФОРМАТ ИТОГОВОГО БРИФА:
            |# Дизайн-бриф: [Название]
            |
            |## О проекте
            |[Описание]
            |
            |## Целевая аудитория
            |[Портрет пользователя]
            |
            |## Стиль и настроение
            |[Описание желаемого стиля]
            |
            |## Цветовая палитра
            |[Предпочтения по цветам]
            |
            |## Референсы
            |[Ссылки или описания]
            |
            |## Ограничения
            |[Что избегать]
            |""".trimMargin()

        private val PROJECT_SUMMARY_INSTRUCTION = """
            |
            |СОБЕРИ СЛЕДУЮЩУЮ ИНФОРМАЦИЮ ДЛЯ РЕЗЮМЕ ПРОЕКТА:
            |1. Название проекта
            |2. Проблема — какую боль решает?
            |3. Решение — как именно решает?
            |4. Уникальность — чем отличается от конкурентов?
            |5. Целевой рынок — кто платит?
            |6. Бизнес-модель — как зарабатывает?
            |7. Текущий статус — что уже сделано?
            |8. Планы — что дальше?
            |
            |ФОРМАТ ИТОГОВОГО РЕЗЮМЕ:
            |# [Название проекта]
            |
            |## Проблема
            |[Описание проблемы]
            |
            |## Решение
            |[Как решаем]
            |
            |## Преимущества
            |• [Преимущество 1]
            |• [Преимущество 2]
            |
            |## Рынок
            |[Целевая аудитория и размер рынка]
            |
            |## Статус
            |[Текущее состояние]
            |
            |## Дорожная карта
            |[Планы развития]
            |""".trimMargin()
    }
}
